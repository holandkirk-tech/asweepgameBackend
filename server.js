const express = require('express');
const cors = require('cors');
const { Pool } = require('pg');
const bcrypt = require('bcrypt');
const crypto = require('crypto');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// Environment variables
const {
  DATABASE_URL,
  ADMIN_USERNAME = 'admin',
  ADMIN_PASSWORD = 'thesecret',
  NODE_ENV = 'development'
} = process.env;

// Database connection with SSL for production
const pool = new Pool({
  connectionString: DATABASE_URL,
  ssl: NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

// Middleware
app.use(cors({ origin: process.env.FRONTEND_ORIGIN || "*", credentials: false }));
app.use(express.json());

// Simplified - no sessions needed

// Spin wheel outcomes with weights
const SPIN_OUTCOMES = [
  { prize: "$100", weight: 0.05, cents: 10000 },
  { prize: "$75", weight: 0.10, cents: 7500 },
  { prize: "$50", weight: 0.15, cents: 5000 },
  { prize: "$25", weight: 0.20, cents: 2500 },
  { prize: "$10", weight: 0.20, cents: 1000 },
  { prize: "$5", weight: 0.20, cents: 500 },
  { prize: "Try Again", weight: 0.10, cents: 0 }
];

// Utility functions

// 5-digit code generator (string to preserve leading zeros if ever needed)
function generateFiveDigitCode() {
  return String(Math.floor(10000 + Math.random() * 90000));
}

// Legacy function for compatibility
function generateSpinCode() {
  return generateFiveDigitCode();
}

// Weighted prize draw:
//  - 50%: lose ("Try again next time")
//  - Remaining 50% distributed with decreasing odds for larger prizes:
//      25% => $5
//      12% => $10
//       7% => $25
//       4% => $50
//       2% => $100
function drawPrize() {
  const roll = Math.random() * 100; // 0..100
  if (roll < 50) return { prize: 0, message: "Try again next time", outcome: "lose" };

  if (roll < 75) return { prize: 5,   message: "You won $5!",   outcome: "win" }; // 25%
  if (roll < 87) return { prize: 10,  message: "You won $10!",  outcome: "win" }; // 12%
  if (roll < 94) return { prize: 25,  message: "You won $25!",  outcome: "win" }; // 7%
  if (roll < 98) return { prize: 50,  message: "You won $50!",  outcome: "win" }; // 4%
  return               { prize: 100, message: "Jackpot! You won $100!", outcome: "win" }; // 2%
}

// Legacy function for compatibility
function selectWeightedOutcome() {
  const result = drawPrize();
  return {
    prize: `$${result.prize}`,
    weight: result.prize === 0 ? 0.5 : (result.prize === 5 ? 0.25 : result.prize === 10 ? 0.12 : result.prize === 25 ? 0.07 : result.prize === 50 ? 0.04 : 0.02),
    cents: result.prize * 100
  };
}

// Database initialization - Updated schema
async function ensureTables() {
  try {
    // Codes generated by admin
    await pool.query(`
      CREATE TABLE IF NOT EXISTS codes (
        id SERIAL PRIMARY KEY,
        code VARCHAR(5) NOT NULL,
        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        expires_at TIMESTAMPTZ NOT NULL,
        is_used BOOLEAN NOT NULL DEFAULT FALSE
      );
    `);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_codes_code ON codes(code);`);

    // Optional: store spin outcomes for analytics
    await pool.query(`
      CREATE TABLE IF NOT EXISTS spin_records (
        id SERIAL PRIMARY KEY,
        code_id INT REFERENCES codes(id) ON DELETE SET NULL,
        prize INT NOT NULL,
        outcome TEXT NOT NULL,            -- "win" | "lose"
        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
      );
    `);

    console.log('âœ… Database tables initialized successfully');
  } catch (error) {
    console.error('âŒ Database initialization error:', error);
  }
}

// No authentication - simplified for temp use

// Routes
// Health check
app.get('/health', (req, res) => {
  res.json({ 
    status: 'Backend is running',
    timestamp: new Date().toISOString(),
    environment: NODE_ENV
  });
});

// (Optional) Health check that also proves DB connectivity
app.get('/api/health', async (_req, res) => {
  try {
    const r = await pool.query("SELECT NOW()");
    res.json({ ok: true, time: r.rows[0].now, env: process.env.VERCEL_ENV || "unknown" });
  } catch (e) {
    res.status(500).json({ ok: false, error: e.message });
  }
});

// Database connection test
app.get('/api/db-test', async (req, res) => {
  try {
    const result = await pool.query('SELECT NOW()');
    res.json({
      status: 'ok',
      time: result.rows[0].now,
      database: 'Connected successfully',
      environment: NODE_ENV
    });
  } catch (err) {
    console.error('DB test failed:', err.message);
    res.status(500).json({
      status: 'error',
      message: err.message,
      database: 'Connection failed'
    });
  }
});

// Admin login route (default: admin / thesecret via env vars)
app.post('/api/admin/login', (req, res) => {
  const { username, password } = req.body;

  if (
    username === ADMIN_USERNAME &&
    password === ADMIN_PASSWORD
  ) {
    return res.json({ success: true, message: 'Login successful' });
  } else {
    return res.status(401).json({ success: false, message: 'Invalid username or password' });
  }
});

// Admin: generate code (valid 3 hours)
app.get('/api/admin/generate-code', async (req, res) => {
  const code = generateFiveDigitCode();
  const expiresAt = new Date(Date.now() + 3 * 60 * 60 * 1000); // 3 hours
  try {
    await pool.query(
      "INSERT INTO codes (code, expires_at) VALUES ($1, $2)",
      [code, expiresAt]
    );
    return res.json({
      success: true,
      code,
      validFor: "3 hours",
      validUntil: expiresAt.toISOString(),
    });
  } catch (err) {
    console.error("generate-code error:", err);
    return res.status(500).json({ success: false, message: "Failed to save code" });
  }
});

// Player: submit code & spin (server decides outcome)
app.post('/api/player/spin', async (req, res) => {
  const { code } = req.body || {};
  if (!code || String(code).length !== 5) {
    return res.status(400).json({ success: false, message: "Invalid code format" });
  }

  try {
    const { rows } = await pool.query(
      `SELECT * FROM codes
       WHERE code = $1
         AND is_used = FALSE
       ORDER BY created_at DESC
       LIMIT 1`,
      [code]
    );

    if (rows.length === 0) {
      return res.status(400).json({ success: false, message: "Invalid or already used code" });
    }

    const dbCode = rows[0];
    const now = new Date();
    const isExpired = now > new Date(dbCode.expires_at);

    if (isExpired) {
      return res.status(400).json({ success: false, message: "Code expired" });
    }

    // Draw outcome with weighted odds
    const result = drawPrize();

    // Mark code as used, store spin record
    await pool.query("UPDATE codes SET is_used = TRUE WHERE id = $1", [dbCode.id]);
    await pool.query(
      "INSERT INTO spin_records (code_id, prize, outcome) VALUES ($1, $2, $3)",
      [dbCode.id, result.prize, result.outcome]
    );

    return res.json({
      success: true,
      prize: result.prize,        // 0 means "Try again next time"
      outcome: result.outcome,    // "win" | "lose"
      message: result.message
    });

  } catch (err) {
    console.error("player/spin error:", err);
    return res.status(500).json({ success: false, message: "Server error" });
  }
});

// Generate spin codes - no auth needed
app.post('/admin/generate', async (req, res) => {
  try {
    const { count = 1 } = req.body;
    const codes = [];
    
    for (let i = 0; i < Math.min(count, 100); i++) {
      const code = generateSpinCode();
      
      try {
        const result = await pool.query(
          'INSERT INTO spin_codes (code) VALUES ($1) RETURNING id, code, created_at',
          [code]
        );
        codes.push(result.rows[0]);
      } catch (dbError) {
        // Handle duplicate code, try again
        if (dbError.code === '23505') {
          i--; // Retry this iteration
          continue;
        }
        throw dbError;
      }
    }
    
    res.json({
      success: true,
      codes,
      generated: codes.length
    });
  } catch (error) {
    console.error('Code generation error:', error);
    res.status(500).json({ error: 'Failed to generate codes' });
  }
});

// Get all generated codes - no auth needed  
app.get('/admin/codes', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT 
        sc.id, sc.code, sc.status, sc.created_at, sc.used_at,
        sr.outcome, sr.prize_cents, sr.odds
      FROM spin_codes sc
      LEFT JOIN spin_results sr ON sc.id = sr.code_id
      ORDER BY sc.created_at DESC
      LIMIT 100
    `);
    
    res.json({
      success: true,
      codes: result.rows
    });
  } catch (error) {
    console.error('Codes fetch error:', error);
    res.status(500).json({ error: 'Failed to fetch codes' });
  }
});

// Verify spin code
app.post('/spin/verify', async (req, res) => {
  try {
    const { code } = req.body;
    
    if (!code || code.length !== 5 || !/^\d{5}$/.test(code)) {
      return res.status(400).json({ error: 'Invalid code format' });
    }
    
    const result = await pool.query(
      'SELECT id, code, status FROM spin_codes WHERE code = $1',
      [code]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Code not found' });
    }
    
    const codeData = result.rows[0];
    
    if (codeData.status === 'used') {
      return res.status(400).json({ error: 'Code already used' });
    }
    
    res.json({
      success: true,
      valid: true,
      code: codeData.code
    });
  } catch (error) {
    console.error('Code verification error:', error);
    res.status(500).json({ error: 'Verification failed' });
  }
});

// Play spin wheel
app.post('/spin/play', async (req, res) => {
  const client = await pool.connect();
  
  try {
    await client.query('BEGIN');
    
    const { code } = req.body;
    
    if (!code || code.length !== 5 || !/^\d{5}$/.test(code)) {
      await client.query('ROLLBACK');
      return res.status(400).json({ error: 'Invalid code format' });
    }
    
    // Check if code exists and is unused
    const codeResult = await client.query(
      'SELECT id, code, status FROM spin_codes WHERE code = $1 FOR UPDATE',
      [code]
    );
    
    if (codeResult.rows.length === 0) {
      await client.query('ROLLBACK');
      return res.status(404).json({ error: 'Code not found' });
    }
    
    const codeData = codeResult.rows[0];
    
    if (codeData.status === 'used') {
      await client.query('ROLLBACK');
      return res.status(400).json({ error: 'Code already used' });
    }
    
    // Select random outcome
    const outcome = selectWeightedOutcome();
    
    // Mark code as used
    await client.query(
      'UPDATE spin_codes SET status = $1, used_at = NOW() WHERE id = $2',
      ['used', codeData.id]
    );
    
    // Save spin result
    const resultInsert = await client.query(`
      INSERT INTO spin_results (code_id, outcome, prize_cents, odds)
      VALUES ($1, $2, $3, $4)
      RETURNING id, outcome, prize_cents, odds, created_at
    `, [codeData.id, outcome.prize, outcome.cents, outcome.weight]);
    
    await client.query('COMMIT');
    
    const spinResult = resultInsert.rows[0];
    
    res.json({
      success: true,
      result: {
        outcome: spinResult.outcome,
        prize_cents: spinResult.prize_cents,
        odds: parseFloat(spinResult.odds),
        spin_id: spinResult.id,
        timestamp: spinResult.created_at
      }
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Spin play error:', error);
    res.status(500).json({ error: 'Spin failed' });
  } finally {
    client.release();
  }
});

// Get spin results - no auth needed
app.get('/admin/results', async (req, res) => {
  try {
    const { limit = 50, offset = 0 } = req.query;
    
    const result = await pool.query(`
      SELECT 
        sr.id, sr.outcome, sr.prize_cents, sr.odds, sr.created_at,
        sc.code
      FROM spin_results sr
      JOIN spin_codes sc ON sr.code_id = sc.id
      ORDER BY sr.created_at DESC
      LIMIT $1 OFFSET $2
    `, [parseInt(limit), parseInt(offset)]);
    
    // Get total count
    const countResult = await pool.query(
      'SELECT COUNT(*) as total FROM spin_results'
    );
    
    res.json({
      success: true,
      results: result.rows,
      total: parseInt(countResult.rows[0].total),
      limit: parseInt(limit),
      offset: parseInt(offset)
    });
  } catch (error) {
    console.error('Results fetch error:', error);
    res.status(500).json({ error: 'Failed to fetch results' });
  }
});

// Admin logout - simplified
app.post('/admin/logout', (req, res) => {
  res.json({ success: true, message: 'Logged out' });
});

// Error handling middleware
app.use((error, req, res, next) => {
  console.error('Unhandled error:', error);
  res.status(500).json({ 
    error: 'Internal server error',
    message: NODE_ENV === 'development' ? error.message : 'Something went wrong'
  });
});

// 404 handler
app.use((req, res) => {
  res.status(404).json({ error: 'Endpoint not found' });
});

// Start server
async function startServer() {
  try {
    // Initialize database
    await ensureTables();
    
    // Start server
    app.listen(PORT, () => {
      console.log(`ðŸŽ° AceSweeps Backend running on port ${PORT}`);
      console.log(`ðŸŒ Environment: ${NODE_ENV}`);
      console.log(`ðŸ”— Health check: http://localhost:${PORT}/health`);
    });
  } catch (error) {
    console.error('âŒ Failed to start server:', error);
    process.exit(1);
  }
}

// Handle graceful shutdown
process.on('SIGINT', async () => {
  console.log('\nðŸ›‘ Shutting down gracefully...');
  await pool.end();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  console.log('\nðŸ›‘ Shutting down gracefully...');
  await pool.end();
  process.exit(0);
});

// Start the server
startServer();

module.exports = app;
